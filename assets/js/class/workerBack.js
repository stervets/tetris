// Generated by CoffeeScript 2.7.0
(function() {
  /*
   * worker.postMessage({
   *  method : {methodName}
   *  vars : {vars}
   *  callback: {callbackFunction}
   * })

      function rand(min, max) {
      if(max == undefined) {
          max = min;
          min = 0;
      }
      return Math.floor(Math.random() * (max - min + 1)) + min;
  }

   */
  var _dump, _mat, collide, getDrop, getFillness, getFullLines, getPath, getPercent, getScore, isFullLine, isInLine, isInVert, matrixCopy, putShape, rand, scoreFormula, spells, triggers, trim, worker;

  importScripts('/assets/js/lib/underscore-min.js', '/assets/js/class/const.js');

  rand = function(min, max) {
    if (max == null) {
      [min, max] = [0, min];
    }
    return Math.floor(Math.random() * (max - min + 1)) + min;
  };

  worker = self;

  _dump = function(...vars) {
    return worker.postMessage({
      callback: 'dump',
      vars: vars
    });
  };

  _mat = function(matrix, id) {
    return worker.postMessage({
      callback: 'mat',
      vars: {
        matrix: matrix,
        id: id
      }
    });
  };

  matrixCopy = function(source) {
    var k, len1, line, matrix;
    matrix = [];
    for (k = 0, len1 = source.length; k < len1; k++) {
      line = source[k];
      matrix.push(line.slice(0));
    }
    return matrix;
  };

  collide = function(matrix, shape, posX, posY) {
    var height, i, j, k, l, len1, len2, line, val, width, x, y;
    width = matrix[0].length;
    height = matrix.length;
    for (i = k = 0, len1 = shape.length; k < len1; i = ++k) {
      line = shape[i];
      y = i + posY;
      for (j = l = 0, len2 = line.length; l < len2; j = ++l) {
        val = line[j];
        x = j + posX;
        if (val && (y >= height || x < 0 || x >= width || (y >= 0 && matrix[y][x]))) {
          return true;
        }
      }
    }
    return false;
  };

  putShape = function(matrix, shape, posX, posY) {
    var height, i, j, k, l, len1, len2, line, overflow, val, width, x, y;
    width = matrix[0].length;
    height = matrix.length;
    overflow = false;
    for (i = k = 0, len1 = shape.length; k < len1; i = ++k) {
      line = shape[i];
      y = i + posY;
      if (y >= height) {
        continue;
      }
      if (y < 0) {
        if (!overflow && isInLine(line)) {
          overflow = true;
        }
        continue;
      }
      for (j = l = 0, len2 = line.length; l < len2; j = ++l) {
        val = line[j];
        x = j + posX;
        if (val && x >= 0 && x < width) {
          matrix[y][x] = val;
        }
      }
    }
    return {
      matrix: matrix,
      overflow: overflow
    };
  };

  isInLine = function(line) {
    var i, k, len1;
    for (k = 0, len1 = line.length; k < len1; k++) {
      i = line[k];
      if (i) {
        return true;
      }
    }
    return false;
  };

  isFullLine = function(line) {
    var i, k, len1;
    for (k = 0, len1 = line.length; k < len1; k++) {
      i = line[k];
      if (!i) {
        return false;
      }
    }
    return true;
  };

  isInVert = function(source, col) {
    var k, len1, line;
    for (k = 0, len1 = source.length; k < len1; k++) {
      line = source[k];
      if (line[col]) {
        return true;
      }
    }
    return false;
  };

  trim = function(source) {
    var i, k, l, len1, line, ref, result, trimLine;
    result = {
      minX: -1,
      maxX: 0,
      minY: -1,
      maxY: 0,
      matrix: [],
      fullLine: -1
    };
    for (i = k = 0, ref = source.length; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
      if (isInVert(source, i)) {
        result.maxX = i;
        if (result.minX < 0) {
          result.minX = i;
        }
      } else {
        if (result.minX > 0) {
          break;
        }
      }
    }
    for (i = l = 0, len1 = source.length; l < len1; i = ++l) {
      line = source[i];
      if (isInLine(line)) {
        trimLine = line.slice(result.minX, +result.maxX + 1 || 9e9);
        result.maxY = i;
        if (result.minY < 0) {
          result.minY = i;
        }
        if (result.fullLine < 0 && isFullLine(trimLine)) {
          result.fullLine = result.matrix.length;
        }
        result.matrix.push(trimLine);
      }
    }
    if (result.minX < 0) {
      result.minX = 0;
    }
    if (result.minY < 0) {
      result.minY = 0;
    }
    result.shiftX = source.length - (result.maxX - result.minX) - 1;
    result.shiftY = source.length - (result.maxY - result.minY) - 1;
    result.width = result.matrix[0].length;
    result.height = result.matrix.length;
    if (result.fullLine < 0) {
      result.fullLine = result.height - 1;
    }
    return result;
  };

  getDrop = function(matrix, shape, x, y) {
    while (!collide(matrix, shape, x, y)) {
      y++;
    }
    return y - 1;
  };

  getFullLines = function(matrix, shape, posX, posY) {
    var full, height, k, l, lines, ref, ref1, width, x, y, yy;
    width = matrix[0].length;
    height = shape.length;
    lines = [];
    for (y = k = 0, ref = height; (0 <= ref ? k < ref : k > ref); y = 0 <= ref ? ++k : --k) {
      yy = y + posY;
      if (yy < 0 || yy >= matrix.length) {
        continue;
      }
      full = true;
      for (x = l = 0, ref1 = width; (0 <= ref1 ? l < ref1 : l > ref1); x = 0 <= ref1 ? ++l : --l) {
        if (!matrix[yy][x] && !shape[y][x - posX]) {
          full = false;
          break;
        }
      }
      if (full) {
        lines.push(yy);
      }
    }
    return lines;
  };

  getPercent = function(part, all) {
    return Math.round((part * 100) / all);
  };

  getFillness = function(matrix, shape, posX, posY, fullLine) {
    var all, filled, holes, inShapeH, inShapeV, k, l, matrixHeight, matrixWidth, ref, ref1, shapeHeight, shapeWidth, x, xx, y, yy;
    shapeWidth = shape[0].length;
    shapeHeight = shape.length;
    matrixWidth = matrix[0].length;
    matrixHeight = matrix.length;
    all = 0;
    filled = 0;
    holes = 0;
// Влияет на holes !!!
    for (y = k = -1, ref = shapeHeight; (-1 <= ref ? k <= ref : k >= ref); y = -1 <= ref ? ++k : --k) {
      yy = y + posY;
      if (!((0 <= yy && yy < matrixHeight))) {
        continue;
      }
      inShapeV = (0 <= y && y < shapeHeight);
      for (x = l = -1, ref1 = shapeWidth; (-1 <= ref1 ? l <= ref1 : l >= ref1); x = -1 <= ref1 ? ++l : --l) {
        xx = x + posX;
        if (!((0 <= xx && xx < matrixWidth))) {
          continue;
        }
        inShapeH = (0 <= x && x < shapeWidth);
        all++;
        if (matrix[yy][xx] || (inShapeV && inShapeH && shape[y][x])) {
          filled++;
        } else {
          if (inShapeH && y >= fullLine) {
            holes++;
          }
        }
      }
    }
    return {
      percent: getPercent(filled, all),
      holes: 100 - getPercent(holes, all)
    };
  };

  scoreFormula = [
    // Склонен строить башни
    function(height,
    fillness,
    holes,
    lines) {
      return height + fillness + holes * 4 + lines;
    },
    // Сбалансирован, но не любит линии.
    function(height,
    fillness,
    holes,
    lines) {
      return height * 2 + fillness + holes * 4 + lines;
    },
    // Слишком любит линии - looser
    function(height,
    fillness,
    holes,
    lines) {
      return height * 2 + fillness + holes * 4 + lines * 2;
    },
    // любит линии!!!
    function(height,
    fillness,
    holes,
    lines) {
      return height * 2 + fillness * 2 + holes * 2 + lines;
    },
    // II лига
    function(height,
    fillness,
    holes,
    lines) {
      return (height + 1) * (holes + 1) + (fillness + 1) * (lines + 1); //4
    },
    
      //увеличить fillness
    function(height,
    fillness,
    holes,
    lines) {
      return ((height + 1) * (holes + 1)) + (fillness * 2 + 1) * (lines + 1); //5
    },
    function(height,
    fillness,
    holes,
    lines) {
      return (height + 1) / (100 - holes + 1) + (lines + 1) * 10 + fillness; //6 RULES
    },
    
      // очков меньше, но стабилен жеж. Выиграл у восьмого, набрав 3050
    function(height,
    fillness,
    holes,
    lines) {
      return (height + 1) / (100 - holes + 1) + (lines + 1) * 2 + (fillness + 1) * 2; //7 nu leader. Абсолютно круче всех.
    },
    
      //мегакрут. Проиграл седьмому на 3485 очках
    function(height,
    fillness,
    holes,
    lines) {
      return (height + 1) / (100 - holes + 1) + (lines + 1) + fillness * 2; //8 слабее 7ки
    },
    //(height, fillness, holes, lines)-> height/((100-holes+1)/2) + lines * 10 + fillness
    function(height,
    fillness,
    holes,
    lines) {
      return fillness / (100 - holes + 1) + lines + height; //9
    },
    function(height,
    fillness,
    holes,
    lines) {
      return (height + 1) / (100 - holes + 1) + (lines + 1) + fillness; //10 наследник восьмого
    },
    function(height,
    fillness,
    holes,
    lines) {
      return ((height + 1) / (100 - holes + 1) + (lines + 1) + fillness) * (height > 50 ? 10 : 1); //11 наследник восьмого
    },
    function(height,
    fillness,
    holes,
    lines) {
      return ((height + 1) / (100 - holes + 1) + (lines + 1) + fillness * 2) * height; //12 На синтетике намного лучше чем 8
    },
    
      // очков меньше, но стабилен жеж. Выиграл у восьмого, набрав 3050
    function(height,
    fillness,
    holes,
    lines) {
      return (fillness + 1) / (100 - holes + 1) + (lines + 1) + (height + 1) * 2; //13 играет опаснее 7ки, но эффективнее по очкам
    },
    function(height,
    fillness,
    holes,
    lines) {
      return (height + 1) / (100 - holes + 1) + (lines + 1) * 2 + (fillness + 1) * 3; //14 уделал семерку и по очкам тоже. Единственный конкурент семерке.
    },
    function(height,
    fillness,
    holes,
    lines) {
      return ((height + 1) * 2) / (100 - holes + 1) + (lines + 1) * 2 + (fillness + 1) * 3; //15 проигрывает семерке, но мне нравится его стиль.
    }
  ];

  
  //(height, fillness, holes, lines)-> height/holes + lines * 10 + fillness # new favorite! 6
  spells = [
    function(matrix,
    value) {
      var empty,
    index,
    k,
    l,
    len,
    len1,
    line,
    lines,
    m,
    ref,
    ref1,
    ref2,
    x,
    y;
      for (index = k = 0, len1 = matrix.length; k < len1; index = ++k) {
        line = matrix[index];
        if (index > value - 1) {
          matrix[index - value] = line.slice(0);
        }
      }
      len = matrix[0].length - 1;
      empty = rand(0,
    len);
      lines = [];
      for (y = l = ref = matrix.length - value, ref1 = matrix.length; (ref <= ref1 ? l < ref1 : l > ref1); y = ref <= ref1 ? ++l : --l) {
        line = [];
        for (x = m = 0, ref2 = len; (0 <= ref2 ? m <= ref2 : m >= ref2); x = 0 <= ref2 ? ++m : --m) {
          line.push(x === empty ? 0 : SHAPE_SPECIAL + SPELL.GROUND);
        }
        lines.push(matrix[y] = line);
      }
      return {
        matrix: matrix,
        spell: lines
      };
    }
  ];

  getScore = function(matrix, shape, posX, posY, formula) {
    var fill, matrixHeight, score, trimShape, x, y;
    if (formula == null) {
      console.log('Warning getScore formula is not set. Setted to 0');
      formula = 0;
    }
    trimShape = trim(shape);
    x = posX + trimShape.minX;
    y = posY + trimShape.minY;
    matrixHeight = matrix.length;
    fill = getFillness(matrix, trimShape.matrix, x, y, trimShape.fullLine);
    score = {
      height: getPercent(y, matrixHeight),
      //    width: getPercent(Math.abs(matrixWidth/2-posX), matrixWidth/2)+1
      fillness: fill.percent,
      holes: fill.holes,
      lines: getPercent(getFullLines(matrix, shape, posX, posY).length, 4)
    };
    //getPercent = (part, all)-> Math.round((part*100)/all)

    //console.log score.lines
    score.score = Math.round(scoreFormula[formula](score.height, score.fillness, score.holes, score.lines));
    return score;
  };

  getPath = function(x1, x2, angle1, angle2) {
    var angle, k, l, ref, ref1, ref2, ref3, result, x;
    result = [];
    for (angle = k = ref = angle1, ref1 = angle2; (ref <= ref1 ? k < ref1 : k > ref1); angle = ref <= ref1 ? ++k : --k) {
      result.push(angle1 < angle2 ? 'rotateRight' : 'rotateLeft');
    }
    for (x = l = ref2 = x1, ref3 = x2; (ref2 <= ref3 ? l < ref3 : l > ref3); x = ref2 <= ref3 ? ++l : --l) {
      result.push(x1 < x2 ? 'moveRight' : 'moveLeft');
    }
    return result;
  };

  triggers = {
    checkMoveDown: function(vars) {
      return worker.postMessage({
        callback: 'checkMoveDown',
        vars: {
          collided: collide(vars.matrix, vars.shape, vars.x, vars.y + 1),
          id: vars.id
        }
      });
    },
    //key: vars.key
    checkMoveLeft: function(vars) {
      return worker.postMessage({
        callback: 'checkMoveLeft',
        vars: {
          collided: collide(vars.matrix, vars.shape, vars.x - 1, vars.y),
          id: vars.id
        }
      });
    },
    checkMoveRight: function(vars) {
      return worker.postMessage({
        callback: 'checkMoveRight',
        vars: {
          collided: collide(vars.matrix, vars.shape, vars.x + 1, vars.y),
          id: vars.id
        }
      });
    },
    checkRotate: function(vars, callback) {
      var collided, halfSize, k, offset, offsetX, ref;
      offsetX = 0;
      if (collided = collide(vars.matrix, vars.shape, vars.x, vars.y)) {
        halfSize = Math.floor(vars.shape[0].length / 2);
        for (offset = k = 1, ref = halfSize; (1 <= ref ? k <= ref : k >= ref); offset = 1 <= ref ? ++k : --k) {
          if (!collide(vars.matrix, vars.shape, vars.x + offset, vars.y)) {
            collided = false;
            offsetX = offset;
            break;
          }
          if (!collide(vars.matrix, vars.shape, vars.x - offset, vars.y)) {
            collided = false;
            offsetX = -offset;
            break;
          }
        }
      }
      return worker.postMessage({
        callback: callback,
        vars: {
          collided: collided,
          x: vars.x + offsetX,
          y: vars.y,
          id: vars.id
        }
      });
    },
    checkRotateLeft: function(vars) {
      return triggers.checkRotate(vars, 'checkRotateLeft');
    },
    checkRotateRight: function(vars) {
      return triggers.checkRotate(vars, 'checkRotateRight');
    },
    checkDrop: function(vars, setDrop = false) {
      //vars.y++ until collide vars.matrix, vars.shape, vars.x, vars.y
      return worker.postMessage({
        callback: 'checkDrop',
        vars: {
          drop: getDrop(vars.matrix, vars.shape, vars.x, vars.y),
          setDrop: setDrop,
          id: vars.id
        }
      });
    },
    setDrop: function(vars) {
      return triggers['checkDrop'](vars, true);
    },
    putShape: function(vars) {
      return worker.postMessage({
        callback: 'putShape',
        vars: {
          result: putShape(matrixCopy(vars.matrix), vars.shape, vars.x, vars.y),
          id: vars.id
        }
      });
    },
    process: function(vars) {
      var _dummy, emptyLine, k, len1, line, lines, matrix, ref, y;
      matrix = [];
      emptyLine = (function() {
        var k, ref, results;
        results = [];
        for (_dummy = k = 0, ref = vars.matrix[0].length; (0 <= ref ? k < ref : k > ref); _dummy = 0 <= ref ? ++k : --k) {
          results.push(0);
        }
        return results;
      })();
      lines = [];
      ref = vars.matrix;
      for (y = k = 0, len1 = ref.length; k < len1; y = ++k) {
        line = ref[y];
        if (isFullLine(line)) {
          matrix.unshift(emptyLine);
          lines.push(y);
        } else {
          matrix.push(line);
        }
      }
      return worker.postMessage({
        callback: 'process',
        vars: {
          matrix: matrix,
          lines: lines,
          id: vars.id
        }
      });
    },
    findPlace: function(vars) {
      var angle, droppedY, formula, k, key, keys, l, len, matrix, matrixWidth, max, maxAngle, ref, ref1, ref2, result, rnd, score, scores, shape, shapeWidth, x, xx, y;
      if (vars.smart == null) {
        //formula = if vars.formula? and scoreFormula[vars.formula]? then vars.formula else 0
        vars.smart = 100;
      }
      formula = vars.formula;
      matrix = vars.matrix;
      matrixWidth = matrix[0].length;
      shapeWidth = vars.shape[0].length;
      x = vars.x;
      y = -vars.shape.length + 1;
      scores = {};
      max = 0;
      maxAngle = SHAPE_ANGLES[vars.shapeIndex] || 4;
      for (xx = k = ref = -shapeWidth, ref1 = matrixWidth; (ref <= ref1 ? k < ref1 : k > ref1); xx = ref <= ref1 ? ++k : --k) {
        for (angle = l = 0, ref2 = maxAngle; (0 <= ref2 ? l < ref2 : l > ref2); angle = 0 <= ref2 ? ++l : --l) {
          shape = vars.shape[angle];
          if ((droppedY = getDrop(matrix, shape, xx, y)) <= 0) {
            continue;
          }
          score = getScore(matrix, shape, xx, droppedY, formula).score;
          if (scores[score] == null) {
            scores[score] = {
              score: score,
              x: xx,
              y: droppedY,
              angle: angle
            };
          }
          if (max < score) {
            max = score;
          }
        }
      }
      //scores.push(max.key)
      keys = Object.keys(scores);
      len = keys.length;
      rnd = -1;
      if (len > 1) {
        rnd = rand(1, 100);
        key = keys[len - (rnd < vars.smart ? 1 : 2)];
      } else {
        key = keys[0];
      }
      //_dump rnd, (if rnd<vars.smart then 'win' else 'fail'), (keys[len-(if rnd<vars.smart then 1 else 2)]+' of '+keys[len-1])
      //rnd = rand(Math.round(keys.length*vars.smart), keys.length)-1
      //key = keys[rnd]

      //break for key in [Math.round(max*vars.smart)..max] when scores[key]?
      //_dump key, scores
      //_dump 'MIN: '+Math.round(keys.length*vars.smart-1)+' of '+(keys.length-1), 'Selected: '+rnd, keys
      result = scores[key] ? (score = scores[key], score.path = getPath(x, score.x, vars.angle, score.angle), score) : {
        path: [],
        score: -1,
        x: x,
        y: -10,
        angle: vars.angle
      };
      result.path = result.path.concat('drop');
      //_dump result
      return worker.postMessage({
        callback: 'findPlace',
        vars: {
          result: result,
          id: vars.id
        }
      });
    },
    getScore: function(vars) {
      var droppedY, res;
      droppedY = getDrop(vars.matrix, vars.shape, vars.x, vars.y);
      res = getScore(vars.matrix, vars.shape, vars.x, droppedY);
      return worker.postMessage({
        callback: 'getScore',
        vars: {
          result: res,
          id: vars.id
        }
      });
    },
    postProcess: function(vars) {
      var ref, res, result, spell, value;
      result = {
        matrix: vars.matrix,
        spell: {}
      };
      ref = vars.spell;
      for (spell in ref) {
        value = ref[spell];
        if (!(value)) {
          continue;
        }
        //console.log spell+' '+value
        res = spells[spell](result.matrix, value);
        result.matrix = res.matrix;
        result.spell[spell] = res.spell;
      }
      return worker.postMessage({
        callback: 'postProcess',
        vars: {
          id: vars.id,
          result: result
        }
      });
    }
  };

  worker.addEventListener('message', function(e) {
    var data;
    data = e.data;
    if (triggers[data.trigger] != null) {
      return triggers[data.trigger](data.vars, data.callback);
    }
  }, false);

}).call(this);

//# sourceMappingURL=workerBack.js.map
