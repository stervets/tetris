// Generated by CoffeeScript 1.7.1

/*
 * worker.postMessage({
 *  method : {methodName}
 *  vars : {vars}
 *  callback: {callbackFunction}
 * })


    function rand(min, max) {
    if(max == undefined) {
        max = min;
        min = 0;
    }
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
 */

(function() {
  var collide, getDrop, getFillness, getFullLines, getPath, getPercent, getScore, isFullLine, isInLine, isInVert, matrixCopy, putShape, rand, scoreFormula, triggers, trim, worker, _dump, _mat,
    __slice = [].slice;

  importScripts('/js/lib/underscore-min.js', '/js/class/const.js');

  rand = function(min, max) {
    var _ref;
    if (max == null) {
      _ref = [0, min], min = _ref[0], max = _ref[1];
    }
    return Math.floor(Math.random() * (max - min + 1)) + min;
  };

  worker = self;

  _dump = function() {
    var vars;
    vars = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return worker.postMessage({
      callback: 'dump',
      vars: vars
    });
  };

  _mat = function(matrix, id) {
    return worker.postMessage({
      callback: 'mat',
      vars: {
        matrix: matrix,
        id: id
      }
    });
  };

  matrixCopy = function(source) {
    var line, matrix, _i, _len;
    matrix = [];
    for (_i = 0, _len = source.length; _i < _len; _i++) {
      line = source[_i];
      matrix.push(line.slice(0));
    }
    return matrix;
  };

  collide = function(matrix, shape, posX, posY) {
    var height, i, j, line, val, width, x, y, _i, _j, _len, _len1;
    width = matrix[0].length;
    height = matrix.length;
    for (i = _i = 0, _len = shape.length; _i < _len; i = ++_i) {
      line = shape[i];
      y = i + posY;
      for (j = _j = 0, _len1 = line.length; _j < _len1; j = ++_j) {
        val = line[j];
        x = j + posX;
        if (val && (y >= height || x < 0 || x >= width || (y >= 0 && matrix[y][x]))) {
          return true;
        }
      }
    }
    return false;
  };

  putShape = function(matrix, shape, posX, posY) {
    var height, i, j, line, overflow, val, width, x, y, _i, _j, _len, _len1;
    width = matrix[0].length;
    height = matrix.length;
    overflow = false;
    for (i = _i = 0, _len = shape.length; _i < _len; i = ++_i) {
      line = shape[i];
      y = i + posY;
      if (y >= height) {
        continue;
      }
      if (y < 0) {
        if (!overflow && isInLine(line)) {
          overflow = true;
        }
        continue;
      }
      for (j = _j = 0, _len1 = line.length; _j < _len1; j = ++_j) {
        val = line[j];
        x = j + posX;
        if (val && x >= 0 && x < width) {
          matrix[y][x] = val;
        }
      }
    }
    return {
      matrix: matrix,
      overflow: overflow
    };
  };

  isInLine = function(line) {
    var i, _i, _len;
    for (_i = 0, _len = line.length; _i < _len; _i++) {
      i = line[_i];
      if (i) {
        return true;
      }
    }
    return false;
  };

  isFullLine = function(line) {
    var i, _i, _len;
    for (_i = 0, _len = line.length; _i < _len; _i++) {
      i = line[_i];
      if (!i) {
        return false;
      }
    }
    return true;
  };

  isInVert = function(source, col) {
    var line, _i, _len;
    for (_i = 0, _len = source.length; _i < _len; _i++) {
      line = source[_i];
      if (line[col]) {
        return true;
      }
    }
    return false;
  };

  trim = function(source) {
    var i, line, result, trimLine, _i, _j, _len, _ref;
    result = {
      minX: -1,
      maxX: 0,
      minY: -1,
      maxY: 0,
      matrix: [],
      fullLine: -1
    };
    for (i = _i = 0, _ref = source.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (isInVert(source, i)) {
        result.maxX = i;
        if (result.minX < 0) {
          result.minX = i;
        }
      } else {
        if (result.minX > 0) {
          break;
        }
      }
    }
    for (i = _j = 0, _len = source.length; _j < _len; i = ++_j) {
      line = source[i];
      if (isInLine(line)) {
        trimLine = line.slice(result.minX, +result.maxX + 1 || 9e9);
        result.maxY = i;
        if (result.minY < 0) {
          result.minY = i;
        }
        if (result.fullLine < 0 && isFullLine(trimLine)) {
          result.fullLine = result.matrix.length;
        }
        result.matrix.push(trimLine);
      }
    }
    if (result.minX < 0) {
      result.minX = 0;
    }
    if (result.minY < 0) {
      result.minY = 0;
    }
    result.shiftX = source.length - (result.maxX - result.minX) - 1;
    result.shiftY = source.length - (result.maxY - result.minY) - 1;
    result.width = result.matrix[0].length;
    result.height = result.matrix.length;
    if (result.fullLine < 0) {
      result.fullLine = result.height - 1;
    }
    return result;
  };

  getDrop = function(matrix, shape, x, y) {
    while (!collide(matrix, shape, x, y)) {
      y++;
    }
    return y - 1;
  };

  getFullLines = function(matrix, shape, posX, posY) {
    var full, height, lines, width, x, y, yy, _i, _j;
    width = matrix[0].length;
    height = shape.length;
    lines = [];
    for (y = _i = 0; 0 <= height ? _i < height : _i > height; y = 0 <= height ? ++_i : --_i) {
      yy = y + posY;
      if (yy < 0 || yy >= matrix.length) {
        continue;
      }
      full = true;
      for (x = _j = 0; 0 <= width ? _j < width : _j > width; x = 0 <= width ? ++_j : --_j) {
        if (!matrix[yy][x] && !shape[y][x - posX]) {
          full = false;
          break;
        }
      }
      if (full) {
        lines.push(yy);
      }
    }
    return lines;
  };

  getPercent = function(part, all) {
    return Math.round((part * 100) / all);
  };

  getFillness = function(matrix, shape, posX, posY, fullLine) {
    var all, filled, holes, inShapeH, inShapeV, matrixHeight, matrixWidth, shapeHeight, shapeWidth, x, xx, y, yy, _i, _j;
    shapeWidth = shape[0].length;
    shapeHeight = shape.length;
    matrixWidth = matrix[0].length;
    matrixHeight = matrix.length;
    all = 0;
    filled = 0;
    holes = 0;
    for (y = _i = -1; -1 <= shapeHeight ? _i <= shapeHeight : _i >= shapeHeight; y = -1 <= shapeHeight ? ++_i : --_i) {
      yy = y + posY;
      if (!((0 <= yy && yy < matrixHeight))) {
        continue;
      }
      inShapeV = (0 <= y && y < shapeHeight);
      for (x = _j = -1; -1 <= shapeWidth ? _j <= shapeWidth : _j >= shapeWidth; x = -1 <= shapeWidth ? ++_j : --_j) {
        xx = x + posX;
        if (!((0 <= xx && xx < matrixWidth))) {
          continue;
        }
        inShapeH = (0 <= x && x < shapeWidth);
        all++;
        if (matrix[yy][xx] || (inShapeV && inShapeH && shape[y][x])) {
          filled++;
        } else {
          if (inShapeH && y >= fullLine) {
            holes++;
          }
        }
      }
    }
    return {
      percent: getPercent(filled, all),
      holes: 100 - getPercent(holes, all)
    };
  };

  scoreFormula = [
    function(height, fillness, holes, lines) {
      return height + fillness + holes * 4 + lines;
    }, function(height, fillness, holes, lines) {
      return height * 2 + fillness + holes * 4 + lines;
    }, function(height, fillness, holes, lines) {
      return height * 2 + fillness + holes * 4 + lines * 2;
    }, function(height, fillness, holes, lines) {
      return height * 2 + fillness * 2 + holes * 2 + lines;
    }, function(height, fillness, holes, lines) {
      return (height + 1) * (holes + 1) + (fillness + 1) * (lines + 1);
    }, function(height, fillness, holes, lines) {
      return ((height + 1) * (holes + 1)) + (fillness * 2 + 1) * (lines + 1);
    }, function(height, fillness, holes, lines) {
      return (height + 1) / (100 - holes + 1) + (lines + 1) * 10 + fillness;
    }, function(height, fillness, holes, lines) {
      return (height + 1) / (100 - holes + 1) + (lines + 1) * 2 + (fillness + 1) * 2;
    }, function(height, fillness, holes, lines) {
      return (height + 1) / (100 - holes + 1) + (lines + 1) + fillness * 2;
    }, function(height, fillness, holes, lines) {
      return fillness / (100 - holes + 1) + lines + height;
    }, function(height, fillness, holes, lines) {
      return (height + 1) / (100 - holes + 1) + (lines + 1) + fillness;
    }, function(height, fillness, holes, lines) {
      return ((height + 1) / (100 - holes + 1) + (lines + 1) + fillness) * (height > 50 ? 10 : 1);
    }, function(height, fillness, holes, lines) {
      return ((height + 1) / (100 - holes + 1) + (lines + 1) + fillness * 2) * height;
    }, function(height, fillness, holes, lines) {
      return (fillness + 1) / (100 - holes + 1) + (lines + 1) + (height + 1) * 2;
    }, function(height, fillness, holes, lines) {
      return (height + 1) / (100 - holes + 1) + (lines + 1) * 2 + (fillness + 1) * 3;
    }, function(height, fillness, holes, lines) {
      return ((height + 1) * 2) / (100 - holes + 1) + (lines + 1) * 2 + (fillness + 1) * 3;
    }
  ];

  getScore = function(matrix, shape, posX, posY, formula) {
    var fill, matrixHeight, score, trimShape, x, y;
    if (formula == null) {
      console.log('Warning getScore formula is not set. Setted to 0');
      formula = 0;
    }
    trimShape = trim(shape);
    x = posX + trimShape.minX;
    y = posY + trimShape.minY;
    matrixHeight = matrix.length;
    fill = getFillness(matrix, trimShape.matrix, x, y, trimShape.fullLine);
    score = {
      height: getPercent(y, matrixHeight),
      fillness: fill.percent,
      holes: fill.holes,
      lines: getPercent(getFullLines(matrix, shape, posX, posY).length, 4)
    };
    score.score = scoreFormula[formula](score.height, score.fillness, score.holes, score.lines);
    return score;
  };

  getPath = function(x1, x2, angle1, angle2) {
    var angle, result, x, _i, _j;
    result = [];
    for (angle = _i = angle1; angle1 <= angle2 ? _i < angle2 : _i > angle2; angle = angle1 <= angle2 ? ++_i : --_i) {
      result.push(angle1 < angle2 ? 'rotateRight' : 'rotateLeft');
    }
    for (x = _j = x1; x1 <= x2 ? _j < x2 : _j > x2; x = x1 <= x2 ? ++_j : --_j) {
      result.push(x1 < x2 ? 'moveRight' : 'moveLeft');
    }
    return result;
  };

  triggers = {
    checkMoveDown: function(vars) {
      return worker.postMessage({
        callback: 'checkMoveDown',
        vars: {
          collided: collide(vars.matrix, vars.shape, vars.x, vars.y + 1),
          id: vars.id,
          key: vars.key
        }
      });
    },
    checkMoveLeft: function(vars) {
      return worker.postMessage({
        callback: 'checkMoveLeft',
        vars: {
          collided: collide(vars.matrix, vars.shape, vars.x - 1, vars.y),
          id: vars.id
        }
      });
    },
    checkMoveRight: function(vars) {
      return worker.postMessage({
        callback: 'checkMoveRight',
        vars: {
          collided: collide(vars.matrix, vars.shape, vars.x + 1, vars.y),
          id: vars.id
        }
      });
    },
    checkRotate: function(vars, callback) {
      var collided, halfSize, offset, offsetX, _i;
      offsetX = 0;
      if (collided = collide(vars.matrix, vars.shape, vars.x, vars.y)) {
        halfSize = Math.floor(vars.shape[0].length / 2);
        for (offset = _i = 1; 1 <= halfSize ? _i <= halfSize : _i >= halfSize; offset = 1 <= halfSize ? ++_i : --_i) {
          if (!collide(vars.matrix, vars.shape, vars.x + offset, vars.y)) {
            collided = false;
            offsetX = offset;
            break;
          }
          if (!collide(vars.matrix, vars.shape, vars.x - offset, vars.y)) {
            collided = false;
            offsetX = -offset;
            break;
          }
        }
      }
      return worker.postMessage({
        callback: callback,
        vars: {
          collided: collided,
          x: vars.x + offsetX,
          y: vars.y,
          id: vars.id
        }
      });
    },
    checkRotateLeft: function(vars) {
      return triggers.checkRotate(vars, 'checkRotateLeft');
    },
    checkRotateRight: function(vars) {
      return triggers.checkRotate(vars, 'checkRotateRight');
    },
    checkDrop: function(vars) {
      return worker.postMessage({
        callback: 'checkDrop',
        vars: {
          drop: getDrop(vars.matrix, vars.shape, vars.x, vars.y),
          id: vars.id
        }
      });
    },
    putShape: function(vars) {
      return worker.postMessage({
        callback: 'putShape',
        vars: {
          result: putShape(matrixCopy(vars.matrix), vars.shape, vars.x, vars.y),
          id: vars.id
        }
      });
    },
    process: function(vars) {
      var emptyLine, line, lines, matrix, y, _dummy, _i, _len, _ref;
      matrix = [];
      emptyLine = (function() {
        var _i, _ref, _results;
        _results = [];
        for (_dummy = _i = 0, _ref = vars.matrix[0].length; 0 <= _ref ? _i < _ref : _i > _ref; _dummy = 0 <= _ref ? ++_i : --_i) {
          _results.push(0);
        }
        return _results;
      })();
      lines = [];
      _ref = vars.matrix;
      for (y = _i = 0, _len = _ref.length; _i < _len; y = ++_i) {
        line = _ref[y];
        if (isFullLine(line)) {
          matrix.unshift(emptyLine);
          lines.push(y);
        } else {
          matrix.push(line);
        }
      }
      return worker.postMessage({
        callback: 'process',
        vars: {
          matrix: matrix,
          lines: lines,
          id: vars.id
        }
      });
    },
    findPlace: function(vars) {
      var angle, droppedY, formula, key, matrix, matrixWidth, max, maxAngle, result, score, scores, shape, shapeWidth, x, xx, y, _i, _j;
      if (vars.smart == null) {
        vars.smart = 1;
      }
      formula = vars.formula;
      matrix = vars.matrix;
      matrixWidth = matrix[0].length;
      shapeWidth = vars.shape[0].length;
      x = vars.x;
      y = -vars.shape.length + 1;
      scores = [];
      max = {
        score: 0,
        key: 0
      };
      maxAngle = SHAPE_ANGLES[vars.shapeIndex] || 4;
      for (xx = _i = -shapeWidth; -shapeWidth <= matrixWidth ? _i < matrixWidth : _i > matrixWidth; xx = -shapeWidth <= matrixWidth ? ++_i : --_i) {
        for (angle = _j = 0; 0 <= maxAngle ? _j < maxAngle : _j > maxAngle; angle = 0 <= maxAngle ? ++_j : --_j) {
          shape = vars.shape[angle];
          if ((droppedY = getDrop(matrix, shape, xx, y)) <= 0) {
            continue;
          }
          score = getScore(matrix, shape, xx, droppedY, formula).score;
          key = scores.length;
          scores.push({
            score: score,
            x: xx,
            y: droppedY,
            angle: angle
          });
          if (max.score < scores[key].score) {
            max = {
              score: scores[key].score,
              key: key
            };
          }
        }
      }
      result = scores[max.key] ? (score = scores[max.key], score.path = getPath(x, score.x, vars.angle, score.angle), score) : {
        path: [],
        score: -1,
        x: x,
        y: -10,
        angle: vars.angle
      };
      result.path = result.path.concat('drop');
      return worker.postMessage({
        callback: 'findPlace',
        vars: {
          result: result,
          id: vars.id
        }
      });
    },
    getScore: function(vars) {
      var droppedY, res;
      droppedY = getDrop(vars.matrix, vars.shape, vars.x, vars.y);
      res = getScore(vars.matrix, vars.shape, vars.x, droppedY);
      return worker.postMessage({
        callback: 'getScore',
        vars: {
          result: res,
          id: vars.id
        }
      });
    }
  };

  worker.addEventListener('message', function(e) {
    var data;
    data = e.data;
    if (triggers[data.trigger] != null) {
      return triggers[data.trigger](data.vars, data.callback);
    }
  }, false);

}).call(this);

//# sourceMappingURL=workerBack.map
