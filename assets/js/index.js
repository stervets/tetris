// Generated by CoffeeScript 2.7.0
(function() {
  Application.shapes = [];

  Application.Model.Controller = {};

  Application.matrixEmpty = function(width, height, val = 0) {
    var _dummy, k, line, matrix, ref;
    line = (function() {
      var k, ref, results;
      results = [];
      for (_dummy = k = 0, ref = width; (0 <= ref ? k < ref : k > ref); _dummy = 0 <= ref ? ++k : --k) {
        results.push(val);
      }
      return results;
    })();
    matrix = [];
    for (_dummy = k = 0, ref = height; (0 <= ref ? k < ref : k > ref); _dummy = 0 <= ref ? ++k : --k) {
      matrix.push(line.slice(0));
    }
    return matrix;
  };

  Application.lineCopy = function(source, value) {
    var k, len1, line, val;
    line = [];
    if (value != null) {
      for (k = 0, len1 = source.length; k < len1; k++) {
        val = source[k];
        line.push(val ? value : 0);
      }
    } else {
      line = source.slice(0);
    }
    return line;
  };

  Application.matrixCopy = function(source, value) {
    var k, len1, line, matrix;
    matrix = [];
    for (k = 0, len1 = source.length; k < len1; k++) {
      line = source[k];
      matrix.push(value != null ? Application.lineCopy(line, value) : line.slice(0));
    }
    return matrix;
  };

  /* Generate rotated shapes and align */
  Application.initShapes = function() {
    var getShapeMatrix, k, len1, matrix, matrixRot90, num, results, shape;
    matrixRot90 = function(source) {
      var cell, i, j, k, l, len, len1, len2, matrix, row;
      matrix = Application.matrixCopy(source);
      len = matrix.length - 1;
      for (i = k = 0, len1 = source.length; k < len1; i = ++k) {
        row = source[i];
        for (j = l = 0, len2 = row.length; l < len2; j = ++l) {
          cell = row[j];
          matrix[j][len - i] = source[i][j];
        }
      }
      return matrix;
    };
    getShapeMatrix = function(shape) {
      var _dummy, k, line, lineStart, matrix, ref, shapeWidth;
      shapeWidth = shape[0].length;
      lineStart = Math.floor(shapeWidth / 2 - shape.length / 2);
      matrix = [];
      for (line = k = 0, ref = shapeWidth; (0 <= ref ? k < ref : k > ref); line = 0 <= ref ? ++k : --k) {
        matrix.push(line >= lineStart && line - lineStart < shape.length ? shape[line - lineStart] : (function() {
          var l, ref1, results;
          results = [];
          for (_dummy = l = 0, ref1 = shapeWidth; (0 <= ref1 ? l < ref1 : l > ref1); _dummy = 0 <= ref1 ? ++l : --l) {
            results.push(0);
          }
          return results;
        })());
      }
      return matrix;
    };
    results = [];
    for (num = k = 0, len1 = SHAPES.length; k < len1; num = ++k) {
      shape = SHAPES[num];
      matrix = Application.shapes[num] = [];
      matrix[0] = getShapeMatrix(shape);
      matrix[1] = matrixRot90(matrix[0]);
      matrix[2] = matrixRot90(matrix[1]);
      results.push(matrix[3] = matrixRot90(matrix[2]));
    }
    return results;
  };

  Application.shapesView = [];

  Application.initShapesView = function() {
    var $shape, index, k, len1, line, ref, results, shape, shapes, val, x, y;
    ref = Application.shapes;
    results = [];
    for (index = k = 0, len1 = ref.length; k < len1; index = ++k) {
      shapes = ref[index];
      Application.shapesView.push([]);
      results.push((function() {
        var l, len2, len3, len4, m, n, results1;
        results1 = [];
        for (l = 0, len2 = shapes.length; l < len2; l++) {
          shape = shapes[l];
          $shape = $(Application.Templates.tplShape()).css({
            width: shape.length * POOL.CELL_SIZE,
            height: shape.length * POOL.CELL_SIZE
          });
          for (y = m = 0, len3 = shape.length; m < len3; y = ++m) {
            line = shape[y];
            for (x = n = 0, len4 = line.length; n < len4; x = ++n) {
              val = line[x];
              if (val) {
                $shape.append(Application.Templates.tplCell({
                  top: y * POOL.CELL_SIZE,
                  left: x * POOL.CELL_SIZE,
                  index: index + 1
                }));
              }
            }
          }
          results1.push(Application.shapesView[index].push($shape[0].outerHTML));
        }
        return results1;
      })());
    }
    return results;
  };

  Application.Model.ShapeStack = (function() {
    /* Main shapes stack */
    class ShapeStack extends Backbone.Model {
      reset() {
        return this.set('shapes', []);
      }

      getShape(index) {
        var len;
        len = index - this.attributes.shapes.length + 2;
        if (len > 0) {
          this.generateShapes(len);
        }
        return {
          index: this.attributes.shapes[index][0],
          angle: this.attributes.shapes[index][1]
        };
      }

      generateShapes(num) {
        var i, k, maxAngle, ref, results, shape;
        results = [];
        for (i = k = 0, ref = num; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          shape = rand(SHAPES.length - 1);
          //shape = 1
          maxAngle = SHAPE_ANGLES[shape] || 4;
          results.push(this.attributes.shapes.push([shape, rand(maxAngle - 1)]));
        }
        return results;
      }

      //@attributes.shapes.push([rand(0,4), rand(maxAngle-1)]) for i in [0...num]
      //@attributes.shapes.push([4, 0]) for i in [0...num]
      init() {
        var data, key;
        this.generateShapes(250);
        return;
        key = 'shapes';
        if (data = window.localStorage.getItem(key)) {
          return this.attributes.shapes = JSON.parse(data);
        } else {
          this.generateShapes(350);
          return window.localStorage.setItem(key, JSON.stringify(this.attributes.shapes));
        }
      }

    };

    ShapeStack.prototype.defaults = {
      shapes: []
    };

    return ShapeStack;

  }).call(this);

  Application.Model.Shape = (function() {
    /* Shape model */
    class Shape extends Backbone.Model {
      setShape(index, angle = 0) {
        var size;
        size = Application.shapes[index][0].length;
        this.set({
          index: index,
          shape: Application.shapes[index],
          size: size,
          angle: angle,
          x: Math.floor(POOL.WIDTH / 2 - size / 2),
          y: -size
        });
        return this.trigger('setShape');
      }

    };

    Shape.prototype.defaults = {
      index: 1000000,
      angle: 0,
      x: 0,
      y: 0,
      drop: -1,
      shape: null,
      size: 0
    };

    return Shape;

  }).call(this);

  // Application keymap
  Application.keyMap = {};

  // Key Mapper
  Application.keyMapper = function(controller, key, action) {
    return Application.keyMap[key] = {
      controller: controller,
      action: action
    };
  };

  /* Hook keys */
  Application.hook = function() {
    $(window).focus(function() {
      return $(document).focus();
    });
    return $(document).keydown(function(e) {
      var map;
      map = Application.keyMap[e.keyCode];
      if (map != null) {
        map.controller.trigger('action', map.action);
        return e.preventDefault();
      }
    });
  };

  /*
  Application.switchView = (viewName)->
      view.trigger('hide') for name, view of Application.GameView when viewName isnt name
      Application.GameView[viewName].trigger('showDelay')
  */
  Application.switchView = function(viewName) {
    var name, ref, view;
    ref = Application.GameView;
    for (name in ref) {
      view = ref[name];
      if (viewName !== name) {
        view.trigger('hide');
      }
    }
    return Application.GameView[viewName].trigger('showDelay');
  };

  // Create menu collection
  Application.createMenu = function(menuTitle, menuItems, context) {
    var menu, menuItem, menuView, title, trigger;
    menu = new Application.Collection.Menu();
    menu.setTitle(menuTitle);
    menuView = new Application.View.Menu({
      collection: {
        Menu: menu
      }
    });
    if (context == null) {
      context = menu;
    }
//_dump(menuView.$el[0].outerHTML)

    //$menuNode = menuView.$('.jsMenuItems')
    for (title in menuItems) {
      trigger = menuItems[title];
      menuItem = new Application.Model.MenuItem({
        title: title,
        triggerHandler: trigger,
        context: context
      });
      menu.add(menuItem);
    }
    return {
      collection: menu,
      view: menuView
    };
  };

  //Application.particle = (params)->

  //<span class="glyphicon glyphicon-star"></span>
  Application.clearCollection = function(collection) {
    var model, results;
    results = [];
    while (collection.length > 0) {
      model = collection.at(0);
      collection.remove(model);
      results.push(model.trigger('destroy'));
    }
    return results;
  };

  /* Start application */
  Application.onStart(function() {
    $('head').append(Application.Templates.tplStyle({
      POOL: POOL,
      poolWidth: POOL.WIDTH * POOL.CELL_SIZE,
      poolHeight: POOL.HEIGHT * POOL.CELL_SIZE
    }));
    Application.initShapes();
    Application.initShapesView();
    Application.shapeStack = new Application.Model.ShapeStack();
    Application.Pool = new Application.Collection.Pool();
    Application.Controller = new Application.Collection.Controller();
    Application.GameView = {};
    Application.Lobby = new Application.Model.Lobby();
    Application.GameView.Lobby = new Application.View.Lobby({
      model: Application.Lobby
    });
    Application.Game = new Application.Model.Game();
    Application.GameMainView = new Application.View.Game({
      model: Application.Game
    });
    Application.hook();
    //Application.Game.switch GAME_MODE.SINGLE_PLAYER
    return Application.Game.switch(GAME_MODE.LOBBY);
  });

  /*
rep = ->
    _dump (Application.Pool.at(0).spell[SPELL.GROUND] if Application.Pool.at(0))
          , (Application.Pool.at(1).spell[SPELL.GROUND] if Application.Pool.at(1))
    setTimeout(rep, 100)
rep()
*/
/*
$('body').click ->
    if pool = Application.Pool.at(0)
        pool.setSpell(SPELL.GROUND, 2)
*/
/*
particle = new Application.Particle
    x: 100
    y: 100

$('body').append particle.$el

$('body').click ->
    for i in [0...10]
        x = i*20
        particle.launch(x, 0, 1, x+(i-10/2)*POOL.CELL_SIZE)
    particle.message('Combo x2', 1)
*/

}).call(this);

//# sourceMappingURL=index.js.map
